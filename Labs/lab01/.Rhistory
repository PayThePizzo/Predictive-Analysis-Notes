# Define the data
# predictor
x <- dataset$body_mass_g
# target
y <- dataset$flipper_length_mm
n <- length(x)
# Sample Variance
s2x <- sum((x-mean(x))^2)/n
s2y <- sum((y-mean(y))^2)/n
# Covariance
covxy <- cov(x,y)
rxy <- cor(x,y)
# Sample Mean
mx <- mean(x)
my <- mean(y)
# Parameters
(beta1 <- rxy * sqrt(s2y/s2x))
(beta0 <- my - beta1 *mx)
# Estimated Values
yhat <- beta0 +  beta1 * x
# Empirical MSE
(mse_hat <- sum((y-yhat)^2))
# Define model
fit <- lm(formula = y ~ x, data = dataset)
# Coefficients
coef(fit)
summary(fit)
SSE <- sum((y-y_hat)^2)
SSE <- sum((y-yhat)^2)
sigma2_hat <- (1/n)*SSE
s2e <- (n/(n-2))*sigma2_hat
se_beta1 <- sqrt(s2e)/sqrt(n*s2x)
(t_obs <- ((beta1-0)/se_beta1))
sigma2_hat <- (1/n)*mse_hat
s2e <- (n/(n-2))*sigma2_hat
se_beta1 <- sqrt(s2e)/sqrt(n*s2x)
(t_obs <- ((beta1-0)/se_beta1))
# Beta star = 1
sigma2_hat <- (1/n)*mse_hat
s2e <- (n/(n-2))*sigma2_hat
se_beta1 <- sqrt(s2e)/sqrt(n*s2x)
(t_obs <- ((beta1-1)/se_beta1))
# Beta star = 1
summary(fit).Coefficients
# Beta star = 1
summary(fit)$Coefficients
# Beta star = 1
fit.Coefficients
# Beta star = 1
fit.coefficients
# Beta star = 1
fit$coefficients
# Beta star = 1
fit$coefficients.x
# Beta star = 1
fit$coefficients$x
# Beta star = 1
fit$coefficients[1]
# Beta star = 1
fit$coefficients[2]
# Beta star = 1
((fit$coefficients[2]-1)/fit$coefficients$Std.Erro)
# Beta star = 1
((fit$coefficients[2]-1)/fit$coefficients$Std.Error[2])
# Beta star = 1
((fit$coefficients[2]-1)/fit$coefficients$StdError[2])
fit$coefficients$StdError[2]
fit$coefficients
fit$std.error
fit$std.error[2]
fit$Std.error[2]
fit$Std.Error[2]
fit$coefficients[2,2]
fit$coefficients[1,2]
fit$coefficients[1,1]
summary(fit)$coefficients[,2]
summary(fit)$coefficients[]
summary(fit)$coefficients[2,2]
# Beta star = 1
((fit$coefficients[2]-1)/summary(fit)$coefficients[2,2])
# Beta star = 1
((fit$coefficients[2]-0)/summary(fit)$coefficients[2,2])
urlLocation <- "https://web.stanford.edu/~hastie/ElemStatLearn/datasets/prostate.data"
prostate <- read.table(urlLocation, header=TRUE)[,1:9]
## explanation of the data
## https://web.stanford.edu/~hastie/ElemStatLearn/datasets/prostate.info.txt
# write.csv("../data/prostate.csv")
plot(prostate)
knitr::opts_chunk$set(echo = TRUE)
# Set working directory
setwd("C:/Users/PayThePizzo/Projects/PredictiveAnalysisNotes/Labs/lab01")
# Get working directory
getwd()
pengs <- read.csv("../data/penguins.csv")
summary(pengs)
pengs <- na.omit(pengs)
# Check the number of rows after cleaning
nrow(pengs)
plot(pengs[,c("flipper_length_mm","body_mass_g")])
x <- pengs$body_mass_g
y <- pengs$flipper_length_mm
n <- length(x)
s2x <- sum((x-mean(x))^2)/n
s2y <- sum((y-mean(y))^2)/n
covxy <- cov(x,y)
rxy <- cor(x,y)
mx <- mean(x)
my<- mean(y)
# Angular coefficient
# Dictates how the y changes in proportion to x
beta1_hat <- rxy * sqrt(s2y/s2x)
# Intercept
# Forces the regression to pass by the sample mean of x and y.
beta0_hat <- my - beta1_hat *mx
# The coefficients
c(beta0_hat, beta1_hat)
# Plot 2D for (xi,yi)
# plot(target ~ predictor, data = df)
plot(flipper_length_mm ~ body_mass_g, data = pengs,pch = 16)
# Adds line y=bo+b1x
abline(beta0_hat, beta1_hat, col = 2, lwd = 1.4)
# Estimated values
yhat <- beta0_hat +  beta1_hat * x
# Empirical MSE
(sum((y-yhat)^2))
# Some random coefficients
(sum((y-(137+0.016*x))^2) )
fit <- lm(flipper_length_mm~body_mass_g, data = pengs)
fit ## in R this corresponds to print(fit)
coef(fit)
coef(fit)
fit$coefficients
tinytex::install_tinytex()
wd()
setwd("C:\Users\PayThePizzo\Projects\Cosma Notes")
setwd(C:\Users\PayThePizzo\Projects\Cosma Notes)
setwd(\Users\PayThePizzo\Projects\Cosma Notes)
getwd
getwd()
setwd("C:/Users/PayThePizzo/Projects/Cosma Notes")
bea <-read.csv("http://www.stat.cmu.edu/~cshalizi/mreg/15/lectures/03/bea-2006.csv")
View(bea)
setwd("C:/Users/PayThePizzo/Projects/Cosma Notes")
write.csv(bea, file="bea-2006")
write.csv(bea, file="bea-2006.csv")
getwd()
# Estimated values
yhat <- beta0_hat +  beta1_hat * x
knitr::opts_chunk$set(echo = TRUE)
# Set working directory
setwd("C:/Users/PayThePizzo/Projects/PredictiveAnalysisNotes/Labs/lab01")
# Get working directory
getwd()
pengs <- read.csv("../data/penguins.csv")
summary(pengs)
pengs <- na.omit(pengs)
# Check the number of rows after cleaning
nrow(pengs)
plot(pengs[,c("flipper_length_mm","body_mass_g")])
x <- pengs$body_mass_g
y <- pengs$flipper_length_mm
n <- length(x)
s2x <- sum((x-mean(x))^2)/n
s2y <- sum((y-mean(y))^2)/n
covxy <- cov(x,y)
rxy <- cor(x,y)
mx <- mean(x)
my<- mean(y)
# Angular coefficient
# Dictates how the y changes in proportion to x
beta1_hat <- rxy * sqrt(s2y/s2x)
# Intercept
# Forces the regression to pass by the sample mean of x and y.
beta0_hat <- my - beta1_hat *mx
# The coefficients
c(beta0_hat, beta1_hat)
# Plot 2D for (xi,yi)
# plot(target ~ predictor, data = df)
plot(flipper_length_mm ~ body_mass_g, data = pengs,pch = 16)
# Adds line y=bo+b1x
abline(beta0_hat, beta1_hat, col = 2, lwd = 1.4)
# Estimated values
yhat <- beta0_hat +  beta1_hat * x
# Empirical MSE
(sum((y-yhat)^2))
# Some random coefficients
(sum((y-(137+0.016*x))^2) )
# Estimated values
yhat <- beta0_hat +  beta1_hat * x
# Empirical MSE
(sum((y-yhat)^2))/n
# Some random coefficients
(sum((y-(137+0.016*x))^2) )/n
summary(fit)
fit <- lm(flipper_length_mm~body_mass_g, data = pengs)
summary(fit)
summary(fit)
sse <- sum((pengs$flipper_length_mm - fit$fitted.values)^2)
(rse <- 1)
summary(fit)
sse <- sum((pengs$flipper_length_mm - fit$fitted.values)^2)
(rse <- sse/nrow(pengs)-2)
summary(fit)
sse <- sum((pengs$flipper_length_mm - fit$fitted.values)^2)
(rse <- sqrt(sse/nrow(pengs)-2))
summary(fit)
sse <- sum((pengs$flipper_length_mm - fit$fitted.values)^2)
s2e <- (n/(n-2))*(sse/n)
summary(fit)
sse <- sum((pengs$flipper_length_mm - fit$fitted.values)^2)
s2e <- (n/(n-2))*(sse/n)
se <- sqrt(s2e)
summary(fit)
sse <- sum((pengs$flipper_length_mm - fit$fitted.values)^2)
s2e <- (n/(n-2))*(sse/n)
se <- sqrt(s2e)
altse <- sqrt((sse/(n-2)))
# Estimated values
yhat <- beta0_hat +  beta1_hat * x
# Empirical MSE
(sum((y-yhat)^2))
# Some random coefficients
(sum((y-(137+0.016*x))^2) )
# Estimated values
yhat <- beta0_hat +  beta1_hat * x
# Empirical MSE
(sum((y-yhat)^2))/n
# Some random coefficients
(sum((y-(137+0.016*x))^2))/n
# sigma from the model is Residual Standard Error
summary(fit)$sigma
(se <- sqrt(sum(residuals(fit)^2)/(n-2)))
(se <-sqrt(sum((pengs$flipper_length_mm  - fitted(fit))^2)/(nrow(pengs)-2)))
summary(fit)$r.squared
## SSreg/SStot
sum((fitted(fit) - mean(pengs$flipper_length_mm))^2)/sum((pengs$flipper_length_mm  - mean(pengs$flipper_length_mm ))^2)
# 1- SSres/SStot
1 - sum((pengs$flipper_length_mm  - fitted(fit))^2)/sum((pengs$flipper_length_mm  - mean(pengs$flipper_length_mm ))^2)
# mean of residuals is null
mean(residuals(fit))
# no correlation with X -
# this does not mean that there is not relationship left between X and the residuals
cor(residuals(fit), pengs$body_mass_g)
head(fitted(fit))
head(predict(fit))
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)))
coef(fit)[1]+coef(fit)[2] * 3500; coef(fit)[1]+coef(fit)[2] * 4000; coef(fit)[1]+coef(fit)[2] * 4700
## what does the slope value mean?
predict(fit, newdata = data.frame(body_mass_g = 3501)) - predict(fit, newdata = data.frame(body_mass_g = 3500))
coef(fit)[2]
## what does the intercept value mean?
predict(fit, newdata = data.frame(body_mass_g = 0))
coef(fit)[1]
sepengs <- sqrt(sum((pengs$flipper_length_mm-fit$fitted.values)^2)/(nrow(pengs)-2))
sepengs
n <- nrow(pengs)
# error for x = 4000
sepengs * sqrt((1/n + ((4000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
(pred1 <- predict(fit, newdata = data.frame(body_mass_g = 4000), se.fit = TRUE))
pred1$se.fit
# error for x = 5000
sepengs * sqrt((1/n + ((5000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
pred2 <- predict(fit, newdata = data.frame(body_mass_g = 5000), se.fit = TRUE)
pred2$se.fit
n <- nrow(pengs)
# error for x = 4000
sepengs * sqrt((1/n + ((4000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
(pred1 <- predict(fit, newdata = data.frame(body_mass_g = 4000), se.fit = TRUE))
pred1$se.fit
# error for x = 5000
sepengs * sqrt((1/n + ((5000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
pred2 <- predict(fit, newdata = data.frame(body_mass_g = 5000), se.fit = TRUE)
pred2$se.fit
mean(pengs$body_mass_g)
predict(fit, newdata = data.frame(body_mass_g = c(1500,4200,5000,8000)), se.fit = TRUE)$se.fit
head(fitted(fit))
head(predict(fit))
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)))
coef(fit)[1]+coef(fit)[2] * 3500; coef(fit)[1]+coef(fit)[2] * 4000; coef(fit)[1]+coef(fit)[2] * 4700
## what does the slope value mean?
predict(fit, newdata = data.frame(body_mass_g = 3501)) - predict(fit, newdata = data.frame(body_mass_g = 3500))
coef(fit)[2]
## what does the intercept value mean?
predict(fit, newdata = data.frame(body_mass_g = 0))
coef(fit)[1]
knitr::opts_chunk$set(echo = TRUE)
head(fitted(fit))
head(predict(fit))
pred1 <- predict(fit, se.fit = TRUE)
## from slides
varmx <- (se^2/n) * (1+(x-mx)^2/s2x)
plot(pengs$body_mass_g, pred1$se.fit, pch = 16, cex = 1.2)
points(pengs$body_mass_g, sqrt(varmx), col = 2, pch = 16)
nd <- data.frame(body_mass_g=c(2000, 3000, 8000),
pippo = c(2000, 3000, 8000))
pred2 <- predict(fit, newdata = nd, se.fit = TRUE)
plot(flipper_length_mm ~ body_mass_g, data = pengs, pch = 16, col = "grey60", xlim = c(2000, 9000), ylim = range(pred2$fit))
points(nd$body_mass_g, pred2$fit, col = "dodgerblue", pch = 4, cex = 1.9, lwd = 3)
abline(coef(fit), col = 2)
coef(fit)
# come interpretare l'intercetta
predict(fit, newdata =  data.frame(body_mass_g=0))
# come interpretare il coef angolare
predict(fit, newdata =  data.frame(body_mass_g=4001)) -
predict(fit, newdata =  data.frame(body_mass_g=4000))
View(nd)
n <- 30
x <- seq(0, 1, length.out = n)
b0 <- 1; b1 <- 2
error <- rexp(n, 1)-1
y <- b0 + b1 * x+ error
plot(x,y)
coef(lm(y~x))
out <- coef(lm(y~x))
set.seed(586328)
for(j in 1:1000){
error <- rexp(n, 1)-1
y <- b0 + b1 * x+ error
out <- rbind(out, coef(lm(y~x)))
}
hist(out[,1]); mean(out[,1])
hist(out[,2]); abline(v = b1, col = 2) ; mean(out[,2])
sd(out[,1])
sd(out[,2])
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "confidence")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "confidence")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "confidence")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "confidence")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "prediction")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "none")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "confidence")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "prediction")
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)), interval = "none")
head(fitted(fit))
head(predict(fit))
predict(fit, newdata = data.frame(body_mass_g = c(3500,4000,4700)))
coef(fit)[1]+coef(fit)[2] * 3500; coef(fit)[1]+coef(fit)[2] * 4000; coef(fit)[1]+coef(fit)[2] * 4700
## what does the slope value mean?
predict(fit, newdata = data.frame(body_mass_g = 3501)) - predict(fit, newdata = data.frame(body_mass_g = 3500))
coef(fit)[2]
## what does the intercept value mean?
predict(fit, newdata = data.frame(body_mass_g = 0))
coef(fit)[1]
sepengs <- sqrt(sum((pengs$flipper_length_mm-fit$fitted.values)^2)/(nrow(pengs)-2))
sepengs
n <- nrow(pengs)
# error for x = 4000
sepengs * sqrt((1/n + ((4000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
(pred1 <- predict(fit, newdata = data.frame(body_mass_g = 4000), se.fit = TRUE))
pred1$se.fit
# error for x = 5000
sepengs * sqrt((1/n + ((5000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
pred2 <- predict(fit, newdata = data.frame(body_mass_g = 5000), se.fit = TRUE)
pred2$se.fit
n <- nrow(pengs)
# error for x = 4000
sepengs * sqrt((1/n + ((4000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
(pred1 <- predict(fit, newdata = data.frame(body_mass_g = 4000), se.fit = TRUE))
pred1$se.fit
# error for x = 5000
sepengs * sqrt((1/n + ((5000-mean(pengs$body_mass_g))^2)/sum((pengs$body_mass_g-mean(pengs$body_mass_g))^2)))
pred2 <- predict(fit, newdata = data.frame(body_mass_g = 5000), se.fit = TRUE)
pred2$se.fit
mean(pengs$body_mass_g)
predict(fit, newdata = data.frame(body_mass_g = c(1500,4200,5000,8000)), se.fit = TRUE)$se.fit
mean(pengs$body_mass_g)
predict(fit, newdata = data.frame(body_mass_g = c(1500,4200,5000,8000)), interval = "prediction", se.fit = TRUE)$se.fit
mean(pengs$body_mass_g)
predict(fit, newdata = data.frame(body_mass_g = c(1500,4200,5000,8000)), interval = "prediction", se.fit = TRUE)
mean(pengs$body_mass_g)
predict(fit, newdata = data.frame(body_mass_g = c(1500,4200,5000,8000)), interval = "confidence", se.fit = TRUE)
head(fitted(fit))
head(predict(fit))
pred1 <- predict(fit, se.fit = TRUE)
## from slides
varmx <- (se^2/n) * (1+(x-mx)^2/s2x)
plot(pengs$body_mass_g, pred1$se.fit, pch = 16, cex = 1.2)
points(pengs$body_mass_g, sqrt(varmx), col = 2, pch = 16)
fit <- lm(flipper_length_mm ~ body_mass_g, data = pengs)
# abline(coef(fit), col = 4)
head(fitted(fit))
head(predict(fit))
pred1 <- predict(fit, se.fit = TRUE)
## from slides
varmx <- (se^2/n) * (1+(x-mx)^2/s2x)
plot(pengs$body_mass_g, pred1$se.fit, pch = 16, cex = 1.2)
points(pengs$body_mass_g, sqrt(varmx), col = 2, pch = 16)
setwd("C:/Users/PayThePizzo/Projects/PredictiveAnalysisNotes/Labs/lab01")
pengs <- read.csv("penguins.csv")
pengs <- na.omit(pengs) ## same dataset without missing values
x <- pengs$body_mass_g
y <- pengs$flipper_length_mm
n <- length(x)
s2x <- sum((x-mean(x))^2)/n
s2y <- sum((y-mean(y))^2)/n
covxy <- cov(x,y)
rxy <- cor(x,y)
mx <- mean(x)
my<- mean(y)
beta1 <- rxy * sqrt(s2y/s2x)
beta0 <- my - beta1 *mx
#plot (target ~ predictor, data = df)
plot(flipper_length_mm ~ body_mass_g, data = pengs,pch = 16)
#Aggiunge retta bo+b1x
abline(beta0, beta1, col = 2, lwd = 1.4)
yhat <- beta0 +  beta1 * x # valori stimati
sum((y-yhat)^2) ## empirical MSE
sum((y-(137+0.016*x))^2)
#lm(target ~ predittori, data = dataset)
fit <- lm(flipper_length_mm ~ body_mass_g, data = pengs)
fit
class(fit)
coef(fit)
summary(fit)
(se <- sqrt(sum((yhat - y)^2)/(n-2)))
head(fitted(fit),10)
head(yhat, 10)
head(residuals(fit), 10)
head((y - yhat), 10)
sqrt(sum(residuals(fit)^2)/(n-2))
sqrt(sum(fit$residuals^2)/(fit$df.residual))
summary(fit)$coefficients[,2]
se/sqrt(n*s2x)
se * sqrt(1/n + mx^2/(n*s2x))
fit <- lm(flipper_length_mm ~ body_mass_g, data = pengs)
# abline(coef(fit), col = 4)
head(fitted(fit))
head(predict(fit))
pred1 <- predict(fit, se.fit = TRUE)
## from slides
varmx <- (se^2/n) * (1+(x-mx)^2/s2x)
plot(pengs$body_mass_g, pred1$se.fit, pch = 16, cex = 1.2)
points(pengs$body_mass_g, sqrt(varmx), col = 2, pch = 16)
nd <- data.frame(body_mass_g=c(2000, 3000, 8000),
pippo = c(2000, 3000, 8000))
pred2 <- predict(fit, newdata = nd, se.fit = TRUE)
plot(flipper_length_mm ~ body_mass_g, data = pengs, pch = 16, col = "grey60", xlim = c(2000, 9000), ylim = range(pred2$fit))
points(nd$body_mass_g, pred2$fit, col = "dodgerblue", pch = 4, cex = 1.9, lwd = 3)
abline(coef(fit), col = 2)
coef(fit)
# come interpretare l'intercetta
predict(fit, newdata =  data.frame(body_mass_g=0))
# come interpretare il coef angolare
predict(fit, newdata =  data.frame(body_mass_g=4001)) -
predict(fit, newdata =  data.frame(body_mass_g=4000))
set.seed(324) # per riproducibilità
n <- 100
x <- runif(n, -1, 1)
## le x sono fissate
## i veri valori dei coefficienti del modello
b0 <- 1; b1 <- 2
# una possibile realizzazione del modello
epsilon <- rexp(n,1)-1 ## errori a media 0
# alcune alternative
# epsilon <- runif(n,-1,1) ## errori a media 0
# epsilon <- runif(n,-3,3) ## errori a media 0
# epsilon <- rgamma(n,shape = 4, scale = 2)-8  ## errori a media 0
# epsilon <- rexp(n,4)-1/4 ## errori a media 0
# epsilon <- rnorm(n,0,2) ## errori a media 0
y <- b0 + b1 * x + epsilon
coef(lm(y~x)) # close enough
## do this 1000 time
generate_get_betas <- function(bs, epsilonpar, x){
ytemp <- b0 + b1 * x + (rexp(length(x),epsilonpar)-1/epsilonpar)
lm(ytemp~x)$coef
}
generate_get_betas(bs= c(b0,b1), epsilonpar = 1, x = x)
out <- replicate(1000, generate_get_betas(bs= c(b0,b1), epsilonpar = 1, x = x))
par(mfrow=c(1,2))
hist(out[1,]);hist(out[2,])
# che forma hanno questi istogrammi?
# unbiased
rowMeans(out)
# variability
apply(out,1,sd)
se <- 1 # V[Y] = 1/lambda^2, when Y ~ exp(1)
s2x <- sum((x-mean(x))^2)/n
c(se * sqrt(1/n + mean(x)^2/(n * s2x)), se * sqrt(1/(n * s2x)))
## change the variability of the error
out2 <- replicate(1000, generate_get_betas(bs= c(b0,b1), epsilonpar = 0.45, x = x))
apply(out2,1,sd)
# still unbiased
apply(out2,1,mean)
gc()
# read the data
fl <- "http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data"
autompg = read.table(fl, quote = "\"",
comment.char = "", stringsAsFactors = FALSE)
# give the dataframe headers
colnames(autompg) <- c("mpg", "cyl", "disp", "hp", "wt",
"acc", "year", "origin", "name")
# remove missing data, which is stored as "?"
autompg <-subset(autompg, autompg$hp != "?")
# remove the plymouth reliant, as it causes some issues
autompg <- subset(autompg, autompg$name != "plymouth reliant")
# give the dataset row names, based on the engine, year and name
rownames(autompg) <- paste(autompg$cyl, "cylinder",
autompg$year, autompg$name)
# remove the variable for name, as well as origin
autompg <- subset(autompg,
select = c("mpg", "cyl", "disp", "hp", "wt", "acc", "year"))
# change horsepower from character to numeric
autompg$hp <- as.numeric(autompg$hp)
fit <- lm(flipper_length_mm~body_mass_g, data = pengs)
# Set working directory
setwd("C:/Users/PayThePizzo/Projects/PredictiveAnalysisNotes/Labs/lab01")
# Get working directory
getwd()
pengs <- read.csv("../data/penguins.csv")
summary(pengs)
fit <- lm(flipper_length_mm~body_mass_g, data = pengs)
summary(fit)
